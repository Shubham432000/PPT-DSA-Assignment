ðŸ’¡ **Q1.** Given an array of integers nums and an integer target, return indices
of the two numbers such that they add up to target. You may assume that each
input would have exactly one solution, and you may not use the same element
twice. You can return the answer in any order. **Example:** Input: nums =
[2,7,11,15], target = 9 Output0 [0,1] **Explanation:** Because nums[0] + nums[1]
== 9, we return [0, 1][ Answer:-
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function twoSum(nums, target) {
        // Create a map to store the numbers and their indices
        const numMap = new Map();

        // Iterate through the array
        for (let i = 0; i < nums.length; i++) {
          const complement = target - nums[i];

          // Check if the complement exists in the map
          if (numMap.has(complement)) {
            // Return the indices of the current number and its complement
            return [numMap.get(complement), i];
          }

          // Store the current number and its index in the map
          numMap.set(nums[i], i);
        }

        // If no solution is found, return an empty array or throw an error
        return [];
      }

      // Example usage:
      const nums = [2, 7, 11, 15];
      const target = 9;
      const result = twoSum(nums, target);
      console.log(result); // Output: [0, 1]
    </script>
  </body>
</html>

ðŸ’¡ **Q2.** Given an integer array nums and an integer val, remove all
occurrences of val in nums in-place. The order of the elements may be changed.
Then return the number of elements in nums which are not equal to val. Consider
the number of elements in nums which are not equal to val be k, to get accepted,
you need to do the following things: - Change the array nums such that the first
k elements of nums contain the elements which are not equal to val. The
remaining elements of nums are not important as well as the size of nums. -
Return k. **Example :** Input: nums = [3,2,2,3], val = 3 Output: 2, nums =
[2,2,_*,_*] **Explanation:** Your function should return k = 2, with the first
two elements of nums being 2. It does not matter what you leave beyond the
returned k (hence they are underscores)[ Answer:-

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function removeElement(nums1, val) {
        let k = 0; // Number of elements not equal to val

        // Iterate through the array
        for (let i = 0; i < nums1.length; i++) {
          // If the current element is not equal to val
          if (nums1[i] !== val) {
            // Overwrite the element at index k with the current element
            nums1[k] = nums1[i];
            k++; // Increment the count of elements not equal to val
          }
        }

        // Return the count of elements not equal to val (k)
        return k;
      }

      // Example usage:
      const nums1 = [3, 2, 2, 3];
      const val = 3;
      const result1 = removeElement(nums1, val);
      console.log(result1); // Output: 2
      console.log(nums1); // Output: [2, 2, _, _]
    </script>
  </body>
</html>

ðŸ’¡ **Q3.** Given a sorted array of distinct integers and a target value, return
the index if the target is found. If not, return the index where it would be if
it were inserted in order. You must write an algorithm with O(log n) runtime
complexity. **Example 1:** Input: nums = [1,3,5,6], target = 5 Output: 2
Answer:-

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function searchInsert(nums2, target2) {
        let left = 0;
        let right = nums2.length - 1;

        while (left <= right) {
          const mid = Math.floor((left + right) / 2);

          if (nums2[mid] === target2) {
            return mid;
          } else if (nums2[mid] < target2) {
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }

        // If the target is not found, return the index where it would be inserted
        return left;
      }

      // Example usage:
      const nums2 = [1, 3, 5, 6];
      const target2 = 5;
      const result2 = searchInsert(nums2, target2);
      console.log(result2); // Output: 2
    </script>
  </body>
</html>

ðŸ’¡ **Q4.** You are given a large integer represented as an integer array digits,
where each digits[i] is the ith digit of the integer. The digits are ordered
from most significant to least significant in left-to-right order. The large
integer does not contain any leading 0's. Increment the large integer by one and
return the resulting array of digits. **Example 1:** Input: digits = [1,2,3]
Output: [1,2,4] **Explanation:** The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4].
Answer:-

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function plusOne(digits) {
        const n = digits.length;

        // Start from the least significant digit
        for (let i = n - 1; i >= 0; i--) {
          // Increment the current digit by one
          digits[i] += 1;

          // If the digit becomes 10, set it to 0 and carry over the 1 to the next digit
          if (digits[i] === 10) {
            digits[i] = 0;
          } else {
            // No carry required, so we can return the digits array
            return digits;
          }
        }

        // If all digits become 0 with a carry remaining, add the carry as a new digit
        digits.unshift(1);

        return digits;
      }

      // Example usage:
      const digits = [1, 2, 3];
      const result4 = plusOne(digits);
      console.log(result4); // Output: [1, 2, 4]
    </script>
  </body>
</html>

ðŸ’¡ **Q5.** You are given two integer arrays nums1 and nums2, sorted in
non-decreasing order, and two integers m and n, representing the number of
elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single
array sorted in non-decreasing order. The final sorted array should not be
returned by the function, but instead be stored inside the array nums1. To
accommodate this, nums1 has a length of m + n, where the first m elements denote
the elements that should be merged, and the last n elements are set to 0 and
should be ignored. nums2 has a length of n. **Example 1:** Input: nums1 =
[1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6]
**Explanation:** The arrays we are merging are [1,2,3] and [2,5,6]. The result
of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function merge(nums5, m, nums6, n) {
        let i = m - 1; // Index of last element in nums1
        let j = n - 1; // Index of last element in nums2
        let k = m + n - 1; // Index of last position in merged array

        // Merge nums1 and nums2 from the end
        while (i >= 0 && j >= 0) {
          if (nums5[i] > nums6[j]) {
            nums5[k] = nums5[i];
            i--;
          } else {
            nums5[k] = nums6[j];
            j--;
          }
          k--;
        }

        // If there are remaining elements in nums2, copy them to nums1
        while (j >= 0) {
          nums5[k] = nums6[j];
          j--;
          k--;
        }

        // nums1 is now the merged and sorted array
        return nums5;
      }

      // Example usage:
      const nums5 = [1, 2, 3, 0, 0, 0];
      const m = 3;
      const nums6 = [2, 5, 6];
      const n = 3;
      const result5 = merge(nums5, m, nums6, n);
      console.log(result5); // Output: [1, 2, 2, 3, 5, 6]
    </script>
  </body>
</html>

**Q6.**ðŸ’¡ Given an integer array nums, return true if any value appears at least
twice in the array, and return false if every element is distinct. **Example
1:** Input: nums = [1,2,3,1] Output: true Answer :-

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function containsDuplicate(nums7) {
        const numSet = new Set();

        // Iterate through the array
        for (let i = 0; i < nums7.length; i++) {
          // Check if the current element is already in the set
          if (numSet.has(nums7[i])) {
            return true;
          }

          // Add the current element to the set
          numSet.add(nums7[i]);
        }

        // No duplicates found
        return false;
      }

      // Example usage:
      const nums7 = [1, 2, 3, 1];
      const result6 = containsDuplicate(nums7);
      console.log(result6); // Output: true
    </script>
  </body>
</html>

ðŸ’¡ **Q7.** Given an integer array nums, move all 0's to the end of it while
maintaining the relative order of the nonzero elements. Note that you must do
this in-place without making a copy of the array. **Example 1:** Input: nums =
[0,1,0,3,12] Output: [1,3,12,0,0] Answer:-

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function moveZeroes(nums8) {
        let i = 0; // Pointer to keep track of non-zero elements

        // Iterate through the array
        for (let j = 0; j < nums8.length; j++) {
          // If the current element is non-zero
          if (nums8[j] !== 0) {
            // Move the non-zero element to the left side of the array
            nums8[i] = nums8[j];
            i++;
          }
        }

        // Fill the remaining positions with zeros
        while (i < nums8.length) {
          nums8[i] = 0;
          i++;
        }

        return nums8;
      }

      // Example usage:
      const nums8 = [0, 1, 0, 3, 12];
      const result7 = moveZeroes(nums8);
      console.log(result7); // Output: [1, 3, 12, 0, 0]
    </script>
  </body>
</html>

ðŸ’¡ **Q8.** You have a set of integers s, which originally contains all the
numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s
got duplicated to another number in the set, which results in repetition of one
number and loss of another number. You are given an integer array nums
representing the data status of this set after the error. Find the number that
occurs twice and the number that is missing and return them in the form of an
array. **Example 1:** Input: nums = [1,2,2,4] Output: [2,3] Answer:-

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function findErrorNums(nums9) {
        const n = nums9.length;
        let duplicate, missing;

        // Traverse the array
        for (let i = 0; i < n; i++) {
          const num = Math.abs(nums9[i]);

          // Check if the current number is already seen
          if (nums9[num - 1] < 0) {
            duplicate = num;
          } else {
            // Mark the current number as seen by negating its value
            nums9[num - 1] *= -1;
          }
        }

        // Find the missing number
        for (let i = 0; i < n; i++) {
          if (nums9[i] > 0) {
            missing = i + 1;
            break;
          }
        }

        return [duplicate, missing];
      }

      // Example usage:
      const nums9 = [1, 2, 2, 4];
      const result8 = findErrorNums(nums9);
      console.log(result8); // Output: [2, 3]
    </script>
  </body>
</html>
